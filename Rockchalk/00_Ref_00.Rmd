
Package ‘rockchalk’
November 9, 2018
Type Package
Title Regression Estimation and Presentation
Version 1.8.129
Date 2018-11-09
Maintainer Paul E. Johnson <pauljohn@ku.edu>

#### Description
 A collection of functions for interpretation and presentation
of regression analysis. These functions are used
to produce the statistics lectures in
<http://pj.freefaculty.org/guides>. Includes regression
diagnostics, regression tables, and plots of interactions and
``moderator'' variables. The emphasis is on ``mean-centered'' and
``residual-centered'' predictors. The vignette 'rockchalk' offers a
fairly comprehensive overview. The vignette 'Rstyle' has advice
about coding in R. The package title 'rockchalk' refers to our
school motto, 'Rock Chalk Jayhawk, Go K.U.'.
License GPL (>= 3.0)
LazyLoad yes
Depends R (>= 2.10)
Imports grDevices, methods, lme4, carData, MASS, kutils
Suggests tables, Hmisc, car
RoxygenNote 6.0.1
NeedsCompilation no
Author Paul E. Johnson [aut, cre],
Gabor Grothendieck [ctb]
Repository CRAN
Date/Publication 2018-11-09 21:10:04 UTC
R topics documented:
rockchalk-package . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3
addLines . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4
1
2 R topics documented:
centerNumerics . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 6
centralValues . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 7
cheating . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 8
checkIntFormat . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 9
checkPosDef . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 10
combineLevels . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 10
cutByQuantile . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11
cutBySD . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 12
cutByTable . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 13
cutFancy . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 13
descriptiveTable . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 15
dir.create.unique . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 17
focalVals . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 18
formatSummarizedFactors . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 19
formatSummarizedNumerics . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 20
genCorrelatedData . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 21
genCorrelatedData2 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 22
genCorrelatedData3 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 25
genX . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 29
getAuxRsq . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 30
getDeltaRsquare . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 31
getFocal . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 32
getPartialCor . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 33
getVIF . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 34
gmc . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 35
kurtosis . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 37
lazyCor . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 38
lazyCov . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 39
lmAuxiliary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 40
magRange . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 40
makeSymmetric . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 41
makeVec . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 42
mcDiagnose . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 43
mcGraph1 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 44
meanCenter . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 46
model.data . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 50
model.data.default . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 51
mvrnorm . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 54
newdata . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 56
outreg . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 63
outreg0 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 68
outreg2HTML . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 72
padW0 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 73
pctable . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 74
perspEmpty . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 77
plot.testSlopes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 78
plotCurves . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 79
plotFancy . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 84
rockchalk-package 3
plotPlane . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 85
plotSeq . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 89
plotSlopes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 90
predictCI . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 95
predictOMatic . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 96
print.pctable . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 103
print.summarize . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 104
print.summary.pctable . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 104
rbindFill . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 105
religioncrime . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 106
removeNULL . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 107
residualCenter . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 108
skewness . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 111
standardize . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 112
summarize . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 113
summarizeFactors . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 116
summarizeNumerics . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 118
summary.factor . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 119
summary.pctable . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 120
testSlopes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 121
vech2Corr . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 123
vech2mat . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 124
waldt . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 125
Index 127
rockchalk-package rockchalk: regression functions

#### Description

Includes an ever-growing collection of functions that assist in the presentation of regression models.
The initial function was outreg, which produces LaTeX tables that summarize one or many
fitted regression models. It also offers plotting conveniences like plotPlane and plotSlopes,
which illustrate some of the variables from a fitted regression model. For a detailed check on multicollinearity,
see mcDiagnose. The user should be aware of this fact: Not all of these functions lead
to models or types of analysis that we endorese. Rather, they all lead to analysis that is endorsed
by some scholars, and we feel it is important to facilitate the comparison of competing methods.
For example, the function standardize will calculate standardized regression coefficients for all
predictors in a regression model’s design matrix in order to replicate results from other statistical
frameworks, no matter how unwise the use of such coefficients might be. The function meanCenter
will allow the user to more selectively choose variables for centering (and possibly standardization)
before they are entered into the design matrix. Because of the importance of interaction variables in
regression analysis, the residualCenter and meanCenter functions are offered. While mean centering
does not actually help with multicollinearity of interactive terms, many scholars have argued
that it does. The meanCenter function can be compared with the "residual centering" of interaction
terms.
4 addLines
Author(s)
Paul E. Johnson <pauljohn@ku.edu>
References
http://pj.freefaculty.org/R
addLines Superimpose regression lines on a plotted plane

#### Description

The 
#### Examples
```{r}

 will demonstrate the intended 
#### Usage
<pre><code>

.

#### Usage
<pre><code>


addLines(to = NULL, from = NULL, col, lwd = 2, lty = 1)

</code></pre>
#### Arguments

to a 3d plot object produced by plotPlane
from output from a plotSlopes or plotCurves function (class="rockchalk")
col color of plotted lines (default: "red")
* ``lwd``:  line width of added lines (default: 2)
lty line type of added lines (default: 1)

#### Details

From an educational stand point, the objective is to assist with the student’s conceptualization of
the two and three dimensional regression relationships.
Value
NULL, nothing, nicht, nada.
Author(s)
Paul E. Johnson <pauljohn@ku.edu>
addLines 5

#### Examples
```{r}


##library(rockchalk)
set.seed(12345)
dfadd <- genCorrelatedData2(100, means = c(0,0,0,0), sds = 1, rho = 0,
beta = c(0.03, 0.01, 0.1, 0.4, -0.1), stde = 2)
dfadd$xcat1 <- gl(2,50, labels=c("M","F"))
dfadd$xcat2 <- cut(rnorm(100), breaks=c(-Inf, 0, 0.4, 0.9, 1, Inf),
labels=c("R", "M", "D", "P", "G"))
dfadd$y2 <- 0.03 + 0.1*dfadd$x1 + 0.1*dfadd$x2 +
0.25*dfadd$x1*dfadd$x2 + 0.4*dfadd$x3 - 0.1*dfadd$x4 +
0.2 * as.numeric(dfadd$xcat1) +
contrasts(dfadd$xcat2)[as.numeric(dfadd$xcat2), ] %*% c(-0.1, 0.1, 0.2, 0) +
1 * rnorm(100)
summarize(dfadd)
## linear ordinary regression
m1 <- lm(y ~ x1 + x2 + x3 + x4, data = dfadd)
summary(m1)
mcDiagnose(m1)
## These will be parallel lines
plotSlopes(m1, plotx = "x1", modx = "x2", modxVals = "std.dev.",
n = 5, main = "A plotSlopes result with \"std.dev.\" values of modx")
m1ps <- plotSlopes(m1, plotx = "x1", modx = "x2", modxVals = c(-2,0,2))
m1pp <- plotPlane(m1, plotx1 = "x1", plotx2 = "x2",
ticktype = "detailed", npp = 10)
addLines(from = m1ps, to = m1pp, lty = 1, lwd = 2)
m1pp <- plotPlane(m1, plotx1 = "x1", plotx2 = "x2", ticktype = "detailed",
npp = 10)
addLines(from = m1ps, to = m1pp, lty = 2, lwd = 5, col = "green")
## Other approach would wrap same into the linesFrom argument in plotPlane
plotPlane(m1, plotx1 = "x1", plotx2 = "x2", ticktype = "detailed",
npp = 10, linesFrom = m1ps)
## Need to think more on whether dotted lines from ps object should
## be converted to solid lines in plotPlane.
```

centerNumerics Find numeric columns, center them, re-name them, and join them with
the original data.

#### Description

The meanCentered regression function requires centered-inputs when calculations are predicted.
For comparison with ordinary regression, it is convenient to have both centered and the original data
side-by-side. This function handles that. If the input data has columns c("x1","x2","x3"), then the
centered result will have columns c("x1","x2","x3","x1c","x2c","x3c"), where "c" indicates "meancentered".
If standardize=TRUE, then the result will have columns c("x1","x2","x3","x1cs","x2cs","x3cs"),
where "cs" indicate "centered and scaled".

#### Usage
<pre><code>


centerNumerics(data, center, standardize = FALSE)

</code></pre>
#### Arguments

* data Required. data frame or matrix.
* center Optional. If nc is NOT supplied, then all numeric columns in data will be centered (possiblly scaled). Can be specified in 2 formats. 1) Vector of column names that are to be centered, 2) Vector named elements giving values of means to be used in centering. Values must be named, as in c("x1" = 17, "x2" = 44).
(possibly scaled).

* standardize Default FALSE. If TRUE, the variables are first mean-centered, and then divided
by their standard deviations (scaled). User can supply a named vector of scale values by which to divide each variable (otherwise sd is used). Vector must have same names and length as center argument. Variables can be entered in any order (will be resorted inside function).

#### Value
A data frame with 1) All original columns 2) additional columns with centered/scaled data, variables
renamed "c" or "cs" to indicate the data is centered or centered and scaled. Attributes "centers" and
"scales" are created for "record keeping" on centering and scaling values.
Author(s)
<pauljohn@ku.edu>

#### Examples
```{r}


set.seed(12345)
dat <- data.frame(x1=rnorm(100, m = 50), x2 = rnorm(100, m = 50),
x3 = rnorm(100, m = 50), y = rnorm(100),
x4 = gl(2, 50, labels = c("Male","Female")))
centralValues 7
datc1 <- centerNumerics(dat)
head(datc1)
summarize(datc1)
datc2 <- centerNumerics(dat, center=c("x1", "x2"))
head(datc2)
summarize(datc2)
attributes(datc2)
datc3 <- centerNumerics(dat, center = c("x1" = 30, "x2" = 40))
head(datc3)
summarize(datc3)
attributes(datc3)
datc4 <- centerNumerics(dat, center=c("x1", "x2"), standardize = TRUE)
head(datc3)
summarize(datc4)
attributes(datc4)
datc5 <- centerNumerics(dat, center=c("x1"=30, "x2"=40),
standardize = c("x2" = 5, "x1" = 7))
head(datc5)
summarize(datc5)
attributes(datc5)
```

centralValues Central Tendency estimates for variables

#### Description

This is needed for the creation of summaries and predicted values of regression models. It takes a
data frame and returns a new data frame with one row in which the mean or mode of the columns
is reported.

#### Usage
<pre><code>
centralValues(x)
</code></pre>
#### Arguments

x a data frame

#### Value
a data frame with the same variables and one row, the summary indicators.
Author(s)
Paul E. Johnson <pauljohn@ku.edu>

#### Examples
```{r}


myDat <- data.frame(x=rnorm(100), y=rpois(100,l=4), z = cut(rnorm(100), c(-10,-1,0,10)))
centralValues(myDat)
```



cutByQuantile Calculates the "center" quantiles, always including the median, when
n is odd.

#### Description

If the numeric variable has fewer than 6 unique observed values, this will send the data to cutByTable.
The default return will find dividing points at three quantiles: c(0.25, 0.50, 0.75) If n=4, the dividing
points will be c(0.20, 0.40, 0.60, 0.80) If n=5, c(0.0, 0.25, 0.50, 0.75, 1.0) Larger n that are odd will
include 0.5 and evenly spaced points out to proportions 0 and 1.0. Larger n that is even will return
evenly spaced points calculated by R's pretty function.


#### Usage
<pre><code>


cutByQuantile(x, n = 3)

</code></pre>
#### Arguments

x A numeric vector.
n The number of quantile points. See 
#### Details
.
Value
A vector
Author(s)
Paul E. Johnson <pauljohn@ku.edu>


cutBySD Returns center values of x, the mean, mean-std.dev, mean+std.dev

#### Description

If the numeric variable has fewer than 6 unique observed values, this will send the data to cut-
ByTable.

#### Usage
<pre><code>
cutBySD(x, n = 3)
</code></pre>
#### Arguments

* ``x``:   A numeric variable
* n Should be an odd number 1, 3, 5, or 7. If 2 < n < 5, values that divide the data at
c(m-sd, m, m+sd) are returned. If n > 4, the returned values are c(m-2sd, m-sd,
m, m+sd, m+2sd).

#### Value
A named vector
Author(s)
Paul E. Johnson <pauljohn@ku.edu>

#### Examples
```{r}
x <- rnorm(100, m = 100, s = 20)
cutBySD (x, n = 3)
cutBySD (x, n = 5)
```

cutByTable Select most frequently occurring values from numeric or categorical
variables.

#### Description

The "n" most frequently occurring values are returned, sorted by frequency of occurrence (in descending
order). The names attribute includes information about the percentage of cases that have
the indicated values.

#### Usage
<pre><code>


cutByTable(x, n = 5, pct = TRUE)

</code></pre>
#### Arguments

* ``x``: A numeric or character variable
* ``n``: The maximum number of values that may be returned.
* ``pct``: Default = TRUE. Include percentage of responses within each category

#### Details

This is used by plotSlopes, plotCurves, and other "newdata" making functions.

#### Value
A named vector.
Author(s)
Paul E. Johnson <pauljohn@ku.edu>

cutFancy Create an ordinal variable by grouping numeric data input.

#### Description

This is a convenience function for Usage of R's cut function. Users can specify cutpoints or category
labels or desired proportions of groups in various ways. In that way, it has a more flexible interface
than cut. It also tries to notice and correct some common user errors, such as omitting the outer
boundaries from the probs argument. The returned values are labeled by their midpoints, rather than
cut’s usual boundaries.

#### Usage
<pre><code>


cutFancy(y, cutpoints = "quantile", probs, categories)
14 cutFancy

</code></pre>
#### Arguments

* ``y``:   The input data from which the categorized variable will be created.
* cutpoints Optional paramter, a vector of thresholds at which to cut the data. If it is not
supplied, the default value cutpoints="quantile" will take effect. Users can
supplement with probs and/or categories as shown in Examples
* probs This is an optional parameter, relevant only when the R function quantile function
is used to calculate cutpoints. The length should be number of desired categories
PLUS ONE, as in c(0, .3, .6, 1). That will create categories that
represent 1) less than .3, between .3 and .6, and above .6. A common user error
is to specify only the internal divider values, such as probs = c(.3,.6). To
anticipate and correct that error, this function will insert the lower limit of 0 and
the upper limit of 1 if they are not already present in probs.
categories Can be a number to designate the number of sub-groups created, or it can be a
vector of names used. If cutpoints and probs are not specified, the parameter
categories should be an integer to specify how many data groups to create.It is
required if cutpoints="quantile" and probs is not specified. Can also be a vector
of names to be used for the categories that are created. If category names are not
provided, the names for the ordinal variable will be the midpoint of the numeric
range from which they are constructed.

#### Details

The dividing points, thought of as "thresholds" or "cutpoints", can be specified in several ways.
cutFancy will automatically create equally-sized sets of observations for a given number of categories
if neither probs nor cutpoints is specified. The bare minimum input needed is categories=5,
for example, to ask for 5 equally sized groups. More user control can be had by specifying either
cutpoints or probs. If cutpoints is not specified at all, or if cutpoints="quantile", then probs
can be used to specify the proportions of the data points that are to fall within each range. On the
other hand, one can specify cutpoints = "quantile" and then probs will be used to specify the
proportions of the data points that are to fall within each range.
If categories is not specified, the category names will be created. Names for ordinal categories
will be the numerical midpoints for the outcomes. Perhaps this will deviate from your expectation,
which might be ordinal categories name "0", "1", "2", and so forth. The numerically labeled values
we provide can be used in various ways during the analysis process. Read "?factor" to learn ways
to convert the ordinal output to other formats. 
Examples include various ways of converting the
ordinal output to numeric.
The categories parameter works together with cutpoints. cutpoints allows a character string
"quantile". If cutpoints is not specified, or if the user specifies a character string cutpoints="quantile",
then the probs would be used to determine the cutpoints. However, if probs is not specified, then
the categories argument can be used. If cutpoints="quantile", then
• if categories is one integer, then it is interpreted as the number of "equally sized" categories
to be created, or
• categories can be a vector of names. The length of the vector is used to determine the
number of categories, and the values are put to use as factor labels.
descriptiveTable 15
Value
an ordinal vector with attributes "cutpoints" and "props" (proportions)

#### Examples
```{r}


set.seed(234234)
y <- rnorm(1000, m = 35, sd = 14)
yord <- cutFancy(y, cutpoints = c(30, 40, 50))
table(yord)
attr(yord, "props")
attr(yord, "cutpoints")
yord <- cutFancy(y, categories = 4L)
table(yord, exclude = NULL)
attr(yord, "props")
attr(yord, "cutpoints")
yord <- cutFancy(y, probs = c(0, .1, .3, .7, .9, 1.0),
categories = c("A", "B", "C", "D", "E"))
table(yord, exclude = NULL)
attr(yord, "props")
attr(yord, "cutpoints")
yord <- cutFancy(y, probs = c(0, .1, .3, .7, .9, 1.0))
table(yord, exclude = NULL)
attr(yord, "props")
attr(yord, "cutpoints")
yasinteger <- as.integer(yord)
table(yasinteger, yord)
yasnumeric <- as.numeric(levels(yord))[yord]
table(yasnumeric, yord)
barplot(attr(yord, "props"))
hist(yasnumeric)
X1a <-
genCorrelatedData3("y ~ 1.1 + 2.1 * x1 + 3 * x2 + 3.5 * x3 + 1.1 * x1:x3",
N = 10000, means = c(x1 = 1, x2 = -1, x3 = 3),
sds = 1, rho = 0.4)
## Create cutpoints from quantiles
probs <- c(.3, .6)
X1a$yord <- cutFancy(X1a$y, probs = probs)
attributes(X1a$yord)
table(X1a$yord, exclude = NULL)
```

model.data.default 51
model.data.default Create a data frame suitable for estimating a model

#### Description

This is the default method. Works for lm and glm fits.

#### Usage
<pre><code>


## Default S3 method:
model.data(model, na.action = na.omit, ...)

</code></pre>
#### Arguments

model A fitted model
na.action Defaults to na.omit, so model as it would appear in user workspace is re-created,
except that rows with missing values are deleted. Changing this argument to
na.pass will provide the data as it was in the workspace.
... Place holder for other arguments, not used at present

#### Value
A data frame
Author(s)
Paul E. Johnson <pauljohn@ku.edu>

#### Examples
```{r}
library(rockchalk)
## first, check if model.data works when there is no data argument
## This used to fail, now OK
x1 <- rnorm(100, m = 100, s = 10)
x2 <- rnorm(100, m = 50, s =20)
y <- rnorm(100, m = 40, s = 3)
m0 <- lm(y ~ log(10+x1) + x2)
m0.data <- model.data(m0)
head(m0.data)
52 model.data.default
m1 <- lm(log(43 + y) ~ log(10+x1) + x2)
m1.data <- model.data(m1)
head(m1.data)
d <- 3
m2 <- lm(log(d + y) ~ log(10+x1) + x2)
m2.data <- model.data(m2)
head(m2.data)
m3 <- lm(log(y + d) ~ log(10+x1) + x2)
m3.data <- model.data(m3)
head(m3.data)
## check numeric and categorical predictors
x1 <- rpois(100, l=6)
x2 <- rnorm(100, m=50, s=10)
x3 <- rnorm(100)
xcat1 <- gl(2,50, labels=c("M","F"))
xcat2 <- cut(rnorm(100), breaks=c(-Inf, 0, 0.4, 0.9, 1, Inf),
labels=c("R", "M", "D", "P", "G"))
dat <- data.frame(x1, x2, x3, xcat1, xcat2)
rm(x1, x2, x3, xcat1, xcat2)
dat$xcat1n <- with(dat, contrasts(xcat1)[xcat1, ,drop=FALSE])
dat$xcat2n <- with(dat, contrasts(xcat2)[xcat2, ])
STDE <- 20
dat$y <- with(dat,
0.03 + 0.8*x1 + 0.1*x2 + 0.7*x3 +
xcat1n %*% c(2) + xcat2n %*% c(0.1,-2,0.3, 0.1) +
STDE*rnorm(100))
m1 <- lm(y ~ poly(x1, 2), data=dat)
m1.data <- model.data(m1)
head(m1.data)
attr(m1.data, "varNamesRHS")
## Check to make sure d is not mistaken for a data column
d <- 2
m2 <- lm(y ~ poly(x1, d), data=dat)
m2.data <- model.data(m2)
head(m2.data)
attr(m2.data, "varNamesRHS")
## Check to see how the 10 in log is handled
m3 <- lm(y ~ log(10 + x1) + poly(x1, d) + sin(x2), data=dat)
model.data.default 53
m3.data <- model.data(m3)
head(m3.data)
attr(m3.data, "varNamesRHS")
m4 <- lm(log(50+y) ~ log(d+10+x1) + poly(x1, 2), data=dat)
m4.data <- model.data(m4)
head(m4.data)
attr(m4.data, "varNamesRHS")
m5 <- lm(y ~ x1*x1, data=dat)
m5.data <- model.data(m5)
head(m5.data)
attr(m5.data, "varNamesRHS")
m6 <- lm(y ~ x1 + I(x1^2), data=dat)
m6.data <- model.data(m6)
head(m6.data)
attr(m6.data, "varNamesRHS")
## Put in some missings.
## poly doesn't work if there are missings, but
## can test with log
dat$x1[sample(100, 5)] <- NA
dat$y[sample(100, 5)] <- NA
dat$x2[sample(100, 5)] <- NA
dat$x3[sample(100,10)] <- NA
m1 <- lm(y ~ log(10 + x1), data=dat)
m1.data <- model.data(m1)
head(m1.data)
summarize(m1.data)
attr(m1.data, "varNamesRHS")
m2 <- lm(y ~ log(x1 + 10), data=dat)
m2.data <- model.data(m2)
head(m2.data)
summarize(m1.data)
attr(m1.data, "varNamesRHS")
d <- 2
m3 <- lm(log(50+y) ~ log(d+10+x1) + x2 + sin(x3), data=dat)
m3.data <- model.data(m3)
head(m3.data)
summarize(m3.data)
attr(m3.data, "varNamesRHS")

m4 <- lm(y ~ I(x1) + I(x1^2) + log(x2), data=dat)
m4.data <- model.data(m4)
summarize(m4.data)
attr(m4.data, "varNamesRHS")
m5 <- lm(y ~ x1 + I(x1^2) + cos(x2), data=dat)
m5.data <- model.data(m5)
head(m5.data)
summarize(m5.data)
attr(m5.data, "varNamesRHS")
## Now try with some variables in the dataframe, some not
x10 <- rnorm(100)
x11 <- rnorm(100)
m6 <- lm(y ~ x1 + I(x1^2) + cos(x2) + log(10 + x10) + sin(x11) +
x10*x11, data = dat)
m6.data <- model.data(m6)
head(m6.data)
dim(m6.data)
summarize(m5.data)
attr(m6.data, "varNamesRHS")
```

mvrnorm Minor revision of mvrnorm (from MASS) to facilitate replication

#### Description

This is the mvrnorm function from the MASS package (Venables and Ripley, 2002), with one small
modification to facilitate replication of random samples. The aim is to make sure that, after the seed
is reset, the first rows of generated data are identical no matter what value is chosen for n. The one
can draw 100 observations, reset the seed, and then draw 110 observations, and the first 100 will
match exactly. This is done to prevent unexpected and peculiar patterns that are observed when n is
altered with MASS package’s mvrnorm.

#### Usage
<pre><code>


mvrnorm(n = 1, mu, Sigma, tol = 1e-06, empirical = FALSE)


</code></pre>
#### Arguments

n the number of samples ("rows" of data) required.
mu a vector giving the means of the variables.
Sigma positive-definite symmetric matrix specifying the covariance matrix of the variables.
tol tolerance (relative to largest variance) for numerical lack of positive-definiteness
in Sigma
empirical logical. If true, mu and Sigma specify the empirical not population mean and
covariance matrix.

#### Details

To assure replication, only a very small change is made. The code in MASS::mvrnorm draws a
random sample and fills a matrix by column, and that matrix is then decomposed. The change
implemented here fills that matrix by row and the problem is eliminated.
Some peculiarities are noticed when the covariance matrix changes from a diagonal matrix to a
more general symmetric matrix (non-zero elements off-diagonal). When the covariance is strictly
diagonal, then just one column of the simulated multivariate normal data will be replicated, but
the others are not. This has very troublesome implications for simulations that draw samples of
various sizes and then base calculations on the separate simulated columns (i.e., some columns are
identical, others are completely uncorrelated).

#### Value
If n = 1 a vector of the same length as mu, otherwise an n by length(mu) matrix with one sample
in each row.
Author(s)
Ripley, B.D. with revision by Paul E. Johnson

#### References
Venables,W. N. & Ripley, B. D. (2002) Modern Applied Statistics with S. Fourth Edition. Springer,
New York. ISBN 0-387-95457-0
See Also
For an alternative multivariate normal generator function, one which has had this fix applied to it,
consider using the new versions of rmvnorm in the package mvtnorm.

#### Examples
```{r}


library(MASS)
library(rockchalk)
set.seed(12345)
X0 <- MASS::mvrnorm(n=10, mu = c(0,0,0), Sigma = diag(3))
56 newdata
## create a smaller data set, starting at same position
set.seed(12345)
X1 <- MASS::mvrnorm(n=5, mu = c(0,0,0), Sigma = diag(3))
## Create a larger data set
set.seed(12345)
X2 <- MASS::mvrnorm(n=15, mu = c(0,0,0), Sigma = diag(3))
## The first 5 rows in X0, X1, and X2 are not the same
X0
X1
X2
set.seed(12345)
Y0 <- mvrnorm(n=10, mu = c(0,0,0), Sigma = diag(3))
set.seed(12345)
Y1 <- mvrnorm(n=5, mu = c(0,0,0), Sigma = diag(3))
set.seed(12345)
Y2 <- mvrnorm(n=15, mu = c(0,0,0), Sigma = diag(3))
# note results are the same in the first 5 rows:
Y0
Y1
Y2
identical(Y0[1:5, ], Y1[1:5, ])
identical(Y1[1:5, ], Y2[1:5, ])
myR <- lazyCor(X = 0.3, d = 5)
mySD <- c(0.5, 0.5, 0.5, 1.5, 1.5)
myCov <- lazyCov(Rho = myR, Sd = mySD)
set.seed(12345)
X0 <- MASS::mvrnorm(n=10, mu = rep(0, 5), Sigma = myCov)
## create a smaller data set, starting at same position
set.seed(12345)
X1 <- MASS::mvrnorm(n=5, mu = rep(0, 5), Sigma = myCov)
X0
X1
##' set.seed(12345)
Y0 <- rockchalk::mvrnorm(n=10, mu = rep(0, 5), Sigma = myCov)
## create a smaller data set, starting at same position
set.seed(12345)
Y1 <- rockchalk::mvrnorm(n=5, mu = rep(0, 5), Sigma = myCov)
Y0
Y1




